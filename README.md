1. HOC - hight order component. (17 урок)
   React.memo - один из HOC-ов (синоним - кеширование) - увеличивает производительность.
   "Защищает" компоненту от излишней перезагрузки (перезагрузки не будет, если непосредственно в этой компоненте не
   произошло каких-либо изменений)

   !!!Все компоненты оборачивать в React.memo

2. Хук useMemo (18 урок).
   Позволяет закешировать результат выполнения кода, например трудоемкого.
   Если в данном коде, результат выполнения которого мы закешировали, не было каких-либо изменений,
   то при перерисовке компоненты этот результат просто будет взят из кеша.
   Нужен для:

* улучшения производительности кода и снижения нагрузки на процессор + ускорение.
* может применяться в тандеме с React.memo (пример использ. см в файле "UseMemoUseCallback")

3. Хук useCallback (19 урок)
   useCallback является синтаксическим сахаром для useMemo при необходимости закешировать функцию.
   Отличия:
   useMemo в качестве первого парам. принимает КОЛЛБЭК, который должен обязательно что-то вернуть (return),
   в нашем случае функцию (т.к. нам нужно закешировать функцию).
   useCallBack в качестве первого параметра принимаем саму эту функцию, которую нам надо закешировать
   В остальном отличий нет
   точные примеры - см. в файле "UseMemoUseCallback", переменные memoizedAddBook1 и memoizedAddBook2
   !!!Все функции, которые мы передаем в качестве пропсов в компоненты, которые в свою очередь обернуты в React.memo,
   нужно всегда оборачивать в useCallback

4. Навороченный useState (20 урок).
   2 интересные особенности useState:
    * хуку useState в качестве инициализационного значения можно передавать функцию. В этом случае при первой отрисовке
      компоненты
      useState возьмет в качестве инициализ. значение результат, которой возвращает эта функция (т.е. он вызовет
      ее внутри себя и возьмет результат вычисления). Данная особенность хука useState очень полезна, когда нам нужно
      передать в качестве инициал. значения результат выполнения трудоемкой функции. Т.е. данная функция вызовется всего
      один раз, т.к. она передана в useState, и не будет вызываться каждый раз при перерисовке компоненты (в этом случае
      для
      избежания повторной перерисовки пришлось бы применять к функции хук useMemo).
    * функции, изменяющей значение значения useState (напр. setCounter), в качестве параметра можно передать не просто
      какое-либо значение, а функцию, которая это значение вычислит и вернет. (см. файл UseState)

5. Хук useEffect (21 урок)
   useEffect является заменой методов жизненного цикла в функциональной компоненте
   useEffect используется в компоненте для проведения каких-либо асинхронных side-эффектов (каких именно - см. файл
   UseEffect)
   когда срабатывает useEffect (3 варианта):
    * useEffect срабатывает каждый раз при перерисовке компоненты в том случае, если мы не передали в него зависимость.
    * Если же зависимость передать, то useEffect будет срабатывать только при изменении этой зависимости.
    * А если в качестве зависимости передать пустой массив, то useEffect сработает только единожды - при вмонтировании
      компоненты,
      далее, при изменениях компоненты он срабатывать не будет (аналог метода componentDidMount).

   !!!Сначала происходит отрисовка компоненты, потом только запускается useEffect

6. Хук useEffect - setTimeout, setInterval (22 урок)
   setTimeout в компоненте использовать только внутри хука useEffect, т.к. если использовать его вне этого хука,
   он будет перезапускаться каждый раз при перерисовке компоненты, что существенно нагружает браузер. Пример см.в.
   файле UseEffect (SetTimeoutExample)
   setInterval также использовать только в хуке useEffect. Пример см.в.
   файле UseEffect (SetIntervalExample)